use strict;
use warnings;
# old style function
our $cmd_timeout;

sub monitorNtp {
  my $base=shift;$base = ".$base";
  my $o=shift;
  my $nsrv=shift;
  my $t=gettimeofday();
  my $cmd="/usr/sbin/ntpdate -t $cmd_timeout -q4 $nsrv";
  my $v;

  foreach (`$cmd`) {
    chomp;
    $v=(split )[9] if ( /time server/ );
  }
  my $r = $? >> 8;
  $$o{$base. '.1.1'} = $v;
  $$o{$base. '.2.1'} = $cmd;
  $$o{$base. '.2.2'} = gettimeofday()-$t;
  $$o{$base. '.2.3'} = $r;
  return $r;
}
# apache httpd mod_status dashboard

#Total Accesses: 58760
#Total kBytes: 37099
#CPULoad: .0188875
#Uptime: 426632
#ReqPerSec: .13773
#BytesPerSec: 89.0448
#BytesPerReq: 646.518
#BusyWorkers: 1
#IdleWorkers: 99

#Scoreboard Key:
#   "_" Waiting for Connection, 
#   "W" Sending Reply, 
#   "R" Reading Request,
#   "K" KeepAlive (read), 
#   "D" DNS Lookup, 

sub apacheStatusMIB {
  my $i=shift;$i = 1; # i is unused
  my $o=shift;
  my @urls=@_;
  my $t=gettimeofday();
  my $cmd="curl -s -m $cmd_timeout ";
  my $r=0;

  foreach my $u (@urls) {
    my $ts=gettimeofday();
    foreach (`$cmd $u`) {
      chomp;
      my $s=$_;
      if ( /Scoreboard/ ) {
        $$o{'apsWaitingForConnection' . ".$i"}=$s=~tr/_/_/; 
        $$o{'apsSendingReply' . ".$i"}=$s=~tr/W/W/; 
        $$o{'apsReadingRequest' . ".$i"}=$s=~tr/R/R/; 
        $$o{'apsKeepAlive' . ".$i"}=$s=~tr/K/K/; 
        $$o{'apsDNSLookup' . ".$i"}=$s=~tr/D/D/; 
      } elsif ( /^Total Accesses/ ) {
        $$o{'apsTotalAccesses' . ".$i"} = ( split /: /, $s )[1];
      } elsif ( /^CPULoad/ ) {
        $$o{'apsCpuLoad' . ".$i"} = ( split /: /, $s )[1];
      } elsif ( /^Uptime/ ) {
        $$o{'apsUptime' . ".$i"} = ( split /: /, $s )[1];
      } elsif ( /^BusyWorkers/ ) {
        $$o{'apsBusyWorkers' . ".$i"} = ( split /: /, $s )[1];
      } elsif ( /^IdleWorkers/ ) {
        $$o{'apsIdleWorkers' . ".$i"} = ( split /: /, $s )[1];
      } elsif ( /^ReqPerSec/ ) {
        $$o{'apsReqPersSec' . ".$i"} = ( split /: /, $s )[1];
      } elsif ( /^BytesPerSec/ ) {
        $$o{'apsBytesPerSec' . ".$i"} = ( split /: /, $s )[1];
      } elsif ( /^BytesPerReq/ ) {
        $$o{'apsBytesPerReq' . ".$i"} = ( split /: /, $s )[1];
      }
    }
    my $cmd_r = $? >> 8;
    $$o{'apsIndex' . ".$i"} = $i;
    $$o{'apsCmdExecTime' . ".$i"} = sprintf('%.3f',scalar gettimeofday() - $ts);
    $$o{'apsCmdExecStatus' . ".$i"} = $cmd_r;
    $$o{'apsUrl' . ".$i"} = $u;
    $r = $cmd_r if $cmd_r;
    $i++;
  }
  $$o{'apsFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'apsFuncExecStatus'} = $r;
  return  $r;
}

sub httpResponseMIB {
  my $i=shift; $i = 1; # i is unused
  my $o=shift;
  my @curl_args=@_;
  my $t=gettimeofday();
  my $cmd="curl -v -s -m $cmd_timeout "; #don't use -v -s -m options for curl args
  my $r=0;

  foreach my $u (@curl_args) {
    my $ts=gettimeofday();
    my ($curl_opt, $content_regex) = split /:/, $u ;
    $$o{"httpRespMatched.$i"} = defined($content_regex)?2:0;
    foreach (`($cmd $curl_opt | sed 's/^/STDOUT:/') 2>&1`) {
      chomp;
      $$o{"httpRespMatched.$i"} = 1 if ( /^STDOUT/ and defined($content_regex) and /$content_regex/ );
      $$o{"httpRespCode.$i"} = ( split )[2] if ( /^< HTTP\// );
    }
    my $cmd_r = $? >> 8;
    $$o{'httpRespIndex' . ".$i"} = $i;
    $$o{'httpRespCmdExecTime' . ".$i"} = sprintf('%.3f',scalar gettimeofday() - $ts);
    $$o{'httpRespCmdExecStatus' . ".$i"} = $cmd_r;
    $$o{'httpRespCurlArgs' . ".$i"} = $u;
    $r = $cmd_r if $cmd_r;
    $i++;
  }
  $$o{'httpRespFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'httpRespFuncExecStatus'} = $r;
  return  $r;
}

sub ntpSyncMIB {
  my $base=shift;
  my $o=shift;
  my $nsrv=shift;
  my $t=gettimeofday();
  my $cmd="/usr/sbin/ntpdate -t $cmd_timeout -q4 $nsrv";
  my $v;

  foreach (`$cmd`) {
    chomp;
    $v=(split )[9] if ( /time server/ );
  }
  my $r = $? >> 8;
  $$o{'ntpSyncStatus'} = sprintf('%.3f', $v);
  $$o{'ntpSyncServer'} = $nsrv;
  $$o{'ntpSyncFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'ntpSyncExecStatus'} = $r;
  return $r;
}

sub procCountMIB {
  my $base=shift;
  my $o=shift;
  my $t=gettimeofday();
  my $cmd='top -b -n1 | awk \'/^Tasks/{print $2 " " $4 " " $6 " " $8 " " $10}\'';
  my ($total, $running, $sleeping, $stopped, $zombie);

  foreach (`$cmd`) {
    chomp;
    ($total, $running, $sleeping, $stopped, $zombie)=split;
  }
  my $r = $? >> 8;
  $$o{'procTotal'} = $total;
  $$o{'procRunning'} = $running;
  $$o{'procSleeping'} = $sleeping;
  $$o{'procStopped'} = $stopped;
  $$o{'procZombie'} = $zombie;
  $$o{'procFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'procExecStatus'} = $r;
  return $r;
}
  
sub ip_conntrackMIB {
  my $base=shift;
  my $o=shift;
  my $t=gettimeofday();
  my $cmd="cat /proc/sys/net/ipv4/netfilter/ip_conntrack_count /proc/sys/net/ipv4/ip_conntrack_max | tr '\n' ' '";
  my ($loaded,$count, $max, $r);

  $loaded=(-f "/proc/sys/net/ipv4/ip_conntrack_max")?1:0;
  if ( $loaded ) {
    foreach (`$cmd`) {
      chomp;
      ($count, $max)=split;
    }
    $r = $? >> 8;
  } else {
    $count = 0;
    $max = 0;
    $r = 0;
  }
  $$o{'ip-conntrackLoaded'} = $loaded;
  $$o{'ip-conntrackCount'} = $count;
  $$o{'ip-conntrackMax'} = $max;
  $$o{'ip-conntrackFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'ip-conntrackExecStatus'} = $r;
  return $r;
}

sub dnsLookUpMIB {
  my $i=shift; $i=1; #parameter is unused
  my $o=shift;
  my @hosts=@_;
  my $t=gettimeofday();
  my $cmd="/usr/bin/host -W $cmd_timeout";
  my $r = 0;

  foreach my $lookup_host (@hosts) {
    my $lookup_ips = '';
    my $ts=gettimeofday();
    foreach (`$cmd $lookup_host`) {
      chomp;
      my $s=$_;
      if ( /has address/ ) {
        $lookup_ips .=  (split / /,$s)[3] . ',';
      }
    }
    my $lookup_r = $? >> 8;
    $$o{'dnsIndex' . ".$i"} = $i;
    $$o{'dnsNameLookUp' . ".$i"} = $lookup_host;
    $$o{'dnsNameResolvedIp' . ".$i"} = $lookup_ips;
    $$o{'dnsLookUpExecTime' . ".$i"} = sprintf('%.3f',scalar gettimeofday() - $ts);
    $$o{'dnsLookUpExecStatus' . ".$i"} = $lookup_r;
    $r = $lookup_r if $lookup_r;
    $i++;
  }
  $$o{'dnsLookUpFuncExecTime'} = sprintf('%.3f',scalar gettimeofday() - $t);
  $$o{'dnsLookUpFuncExecStatus'} = $r;
  return  $r;
}

sub osInfoMIB {
  my $i=shift; $i=1; #parameter is unused
  my $o=shift;
  $$o{'osinfoRelease'} = `head -1 /etc/redhat-release` if ( -f '/etc/redhat-release' );
  $$o{'osinfoSoftwareLastChange'} =  (stat('/var/lib/rpm/Packages'))[9] if ( -f '/var/lib/rpm/Packages' );
  return 0;  
}

sub lastLoginsMIB {
  my $i=shift; $i=1; #parameter is unused
  my $o=shift;
  my $t=gettimeofday();
  my $r;

  foreach  (`w -h`) {
    chomp;
    $$o{'loggedInUserIndex.' . $i} = $i;
    $$o{'loggedInUserInfo.' . $i} = $_;
    $i++;
  }
  $$o{'loggedInUsersCount'} = $i-1;

  $r = $? >> 8;

  $i=1;  

  foreach  (`last -w -n 20`) {
    chomp;
    next if ( /^$/ );
    if ( /^wtmp begins/ ) {
      $$o{'wtmpBegins'} = $_;
      next;
    }

    $$o{'lastUserIndex.' . $i} = $i;
    $$o{'lastUserInfo.' . $i} = $_;
    $i++;
  }
  $r = $r || ($? >> 8);
  return $r;
}

return 1;
