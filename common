use warnings;
use strict;

use Sys::Syslog qw(:standard :macros);
use Sys::Hostname;
use SNMP;
use NetSNMP::ASN qw(:all);

our $subAgentDir;
our ($reg_oid, $poller_cycle, $stale_time, $log_to_console, $cmd_timeout, $shm_size);
our %oDescr;

SNMP::initMib(); # parses default list of Mib modules from default dirs
SNMP::addMibDirs("${subAgentDir}mibs/");
SNMP::loadModules("ALL");
return 1;

sub unpackMessage {
  my $shm_message = shift;
  my $oData = shift;
  my %shm_data = unpack( 'S/(S/A* S/A*)', $shm_message );
  my %typeMap = ( 'GAUGE'=>ASN_GAUGE,'TICKS'=>ASN_TIMETICKS,'INTEGER'=>ASN_INTEGER, 'INTEGER32'=>ASN_INTEGER,'COUNTER64'=>ASN_COUNTER64,'OCTETSTR'=>ASN_OCTET_STR );
  while ( my($k,$v) = each %shm_data) { 
    if ( $k !~ /^\./ ) { 
      # a mib variable with or without index
      my ( $mvar, $idx ) = split /\./, $k; 
      if (my $node = $SNMP::MIB{$mvar}) { 
        $$oData{($node->{'objectID'}) . (defined($idx)?".$idx":'') }->{'V'} = $v;
        $$oData{($node->{'objectID'}) . (defined($idx)?".$idx":'') }->{'T'} = $typeMap{$node->{'type'}};
#        logMessage(LOG_DEBUG, "Type $node->{'objectID'} is $node->{'type'} map to $typeMap{$node->{'type'}}" ); 
      } else {
        logMessage(LOG_ERR, "$k is not found in a MIB, skipping"); 
      }
    }
  }
  return (sort { new NetSNMP::OID($a)<=>new NetSNMP::OID($b) } ( keys %$oData ) );
}

sub unpackOData {
  my $r = shift;
  return ( defined($$r{'T'})?$$r{'T'}:ASN_OCTET_STR, $$r{'V'} );
}

sub logMessage {
  my $level = shift;
  my $msg = shift;
  openlog( "snmpd-poller", 'pid', LOG_DAEMON );
  syslog ( $level, $msg );
  closelog;
  print STDERR "$msg\n" if defined($log_to_console) && $log_to_console != 0;
}

sub readConfig {
  logMessage(LOG_INFO, "Reading config ...");
  %oDescr=();
# process the main configuration file
  open(CONFIG,"${subAgentDir}/snmpd-poller.conf") or die;
  while(<CONFIG>) {
    chomp;
    s/ //g;
    next if ( /^(#|$)/ );
    my @c=split /=/, $_, 2;
    die "error $#c" if $#c != 1;
    if ($c[0] eq 'reg_oid') {
      $reg_oid=$c[1];
    } elsif ($c[0] eq 'poller_cycle') {
      $poller_cycle=$c[1];
    } elsif ($c[0] eq 'stale_time') {
      $stale_time=$c[1];
    } elsif ($c[0] eq 'log_to_console') {
      $log_to_console=$c[1];
    } elsif ($c[0] eq 'cmd_timeout') {
      $cmd_timeout=$c[1];
    } elsif ($c[0] eq 'shm_size') {
      $shm_size=$c[1];
    } elsif ($c[0] eq 'function') {
      logMessage(LOG_WARNING, "functions in snmpd-poller.conf are depreciated");  
    } else {
      logMessage(LOG_ERR, "unexpected token $c[0] in config file,ignoring");  
    }  
  }
  close CONFIG;

# do not load functions in the agent
  return 0 if $0 !~ 'snmpd-poller$'; 

# load extention functions
  foreach my $ff ( glob "${subAgentDir}*.functions" ) {
    logMessage(LOG_DEBUG, "loading functions from  $ff");
    require "$ff";
  }
# process hostname based configuration files
  my $h = hostname;
  foreach my $f_config ( (glob "${subAgentDir}snmpd-poller*.conf"), (glob "${subAgentDir}conf.d/${h}*.conf")) {
    logMessage(LOG_DEBUG, "loading config from  $f_config");
    open(S_CONFIG,"$f_config") or die;
    while(<S_CONFIG>) {
      chomp;
      s/ //g;
      next if ( /^(#|$)/ );
      my @c=split /=/, $_, 2;
      die "error $#c" if $#c != 1;
      if ($c[0] eq 'function') { 
        my @oArg = split /,/, $c[1];
        my ($bi,$f) = ( shift @oArg, shift @oArg );
        my $k = pack('d a*', $bi, $f );
        logMessage( LOG_WARNING, "functions for $bi, $f is already defined, redefining") if defined($oDescr{$k}); 
        $oDescr{$k}=[@oArg];
      }     
    }
    close S_CONFIG;
  }
}
